% Copyright (c) 2012 Physion Consulting LLC

function experiment = ImportCell(context,...
        experiment,...
        sourceID,...
        probeStimPath,...
        probeSpikesPath,...
        testStimPath,...
        testSpikesPath,...
        parameters)
    
    import ovation.*;
    
    disp(['Importing cell from source ' sourceID '...']);
        
    probeStim = readTextData(probeStimPath);
    probeSpikes = readTextData(probeSpikesPath);
    
    testStim = readTextData(testStimPath);
    testSpikes = readTextData(testSpikesPath);
    
    [cellSource,~] = sourceForInsertion(context,...
        {sourceID},...
        {'cell_number'},...
        {sourceID});
    
    insertProbeGroup(experiment,...
        cellSource,...
        'probe',...
        'org.mbl.mcn.2012.ps2.stim.gaussian',...
        probeStim,...
        probeSpikes,...
        parameters.probe);
    
    insertTestGroup(experiment,...
        cellSource,...
        'test',...
        'org.mbl.mcn.2012.ps2.stim.repeated_gaussian',...
        testStim,...
        testSpikes,...
        parameters.test);
    
end

function insertProbeGroup(experiment,...
        cellSource,...
        groupLabel,...
        stimID,...
        stimData,...
        spikes,...
        parameters)
    
    import ovation.*
    
    group = experiment.insertEpochGroup(cellSource,...
        groupLabel,...
        experiment.getStartTime());
    group.addTag(cellSource.getLabel());
    
    epoch = group.insertEpoch(group.getStartTime(),...
        group.getStartTime().plusSeconds(parameters.epochDurationSeconds),...
        ['org.mbl.mcn.2012.ps2.' groupLabel],...
        struct2map(struct()));
    
    stimParams = parameters.stimParameters;
    stimParams.stimData = NumericData(stimData);
    epoch.insertStimulus(experiment.externalDevice('Stimulator','MCN'),... % TODO
        struct2map(struct()),...
        stimID,...
        struct2map(stimParams),...
        'a.u.',... %TODO
        'V'); %TODO
    
    trace = fabricateOriginalResponse(spikes,...
        parameters.stimParameters.sampleRate,...
        parameters.epochDurationSeconds);
    
    r = epoch.insertResponse(experiment.externalDevice('Model Cell','MCN'),...
        struct2map(struct()),...
        trace,...
        'mV',...
        'membrane voltage',...
        parameters.stimParameters.sampleRate,...
        parameters.stimParameters.sampleRateUnits,...
        IResponseData.NUMERIC_DATA_UTI);
    
    epoch.addProperty('fabricated_spike_width_s', 0.2);
    r.addTag('fabricated');
    
    derivationParams.threshold_mV = 20; %mv
    epoch.insertDerivedResponse('spikes',...
        NumericData(spikes),...
        's',...
        struct2map(derivationParams),...
        {'spike times'});
    
end

function insertTestGroup(experiment,...
        cellSource,...
        groupLabel,...
        stimID,...
        stimData,...
        spikes,...
        parameters)
    
    import ovation.*
    
    group = experiment.insertEpochGroup(cellSource,...
        groupLabel,...
        experiment.getStartTime());
    group.addTag(cellSource.getLabel());
    
    % If spike times are monotonic (cell 4), make times repeat-relative
    if(any(floor(spikes) > parameters.stimParameters.durationSeconds))
        for i = 1:parameters.stimParameters.numRepetitions
            startSeconds = (i-1)*parameters.stimParameters.durationSeconds;
            endSeconds = (i)*parameters.stimParameters.durationSeconds;
            spikes(spikes >= startSeconds & spikes < endSeconds) = ...
                spikes(spikes >= startSeconds & spikes < endSeconds) - startSeconds;
        end
                
    end
    
    % Split spike times into epochs
    
    epochEndBoundaries = find(spikes(1:length(spikes)-1) > spikes(2:end));
    
    % Add split stim and reponse epochs
    for i = 1:parameters.stimParameters.numRepetitions
        
        if(i == 1)
            epochSpikes = spikes(1:epochEndBoundaries(i));
        elseif(i == parameters.stimParameters.numRepetitions)
            epochSpikes = spikes((epochEndBoundaries(i-1)+1):end);
        else
            epochSpikes = spikes((epochEndBoundaries(i-1)+1):epochEndBoundaries(i));
        end
        
        stimParams = parameters.stimParameters;
        stimParams.stimData = NumericData(stimData);
        
        epochStartTime = group.getStartTime().plusSeconds(parameters.stimParameters.durationSeconds*(i-1));
        
        epoch = group.insertEpoch(epochStartTime,...
            epochStartTime.plusSeconds(parameters.stimParameters.durationSeconds),...
            ['org.mbl.mcn.2012.ps2.' groupLabel],...
            struct2map(struct()));
        
        epoch.insertStimulus(experiment.externalDevice('Stimulator','MCN'),... % TODO
            struct2map(struct()),...
            stimID,...
            struct2map(stimParams),...
            'a.u.',... %TODO
            'V'); %TODO
        
        
        trace = fabricateOriginalResponse(epochSpikes,...
            parameters.stimParameters.sampleRate,...
            parameters.stimParameters.durationSeconds);
        
        r = epoch.insertResponse(experiment.externalDevice('Model Cell','MCN'),...
            struct2map(stimParams),...
            trace,...
            'mV',...
            'membrane voltage',...
            parameters.stimParameters.sampleRate,...
            parameters.stimParameters.sampleRateUnits,...
            IResponseData.NUMERIC_DATA_UTI);
        
        epoch.addProperty('fabricated_spike_width_s', 0.2);
        
        r.addTag('fabricated');
        
        derivationParams.threshold_mV = 20; %mv
        epoch.insertDerivedResponse('spikes',...
            NumericData(epochSpikes),...
            's',...
            struct2map(derivationParams),...
            {'spike times'});
    end
    
end

function resultMv = fabricateOriginalResponse(spikes, srate, duration)
    import ovation.*;
    
    spikeIdx = int32(spikes*srate);
    
    resp = -60 * ones(1, ceil(duration*srate));
    
    resp(spikeIdx(spikeIdx > 1) - 1) = 0;
    resp(spikeIdx(spikeIdx > 0)) = 50;
    
    resultMv = NumericData(resp);
end
